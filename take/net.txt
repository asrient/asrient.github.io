-->>Commands to be run on Terminal before Uploading Arduino code to NodeMCU ESP32:

sudo apt-get install python-serial python3-serial

sudo chmod a+rw /dev/ttyUSB0

------------------------------------------------------------------------------------------------------------------------

1. Getting Started with LED Blinking.

Code:

void setup() {
  // initialize digital pin LED_BUILTIN as an output.
  pinMode(LED_BUILTIN, OUTPUT);
}

// the loop function runs over and over again forever
void loop() {
  digitalWrite(LED_BUILTIN, HIGH);   // turn the LED on (HIGH is the voltage level)
  delay(1000);                       // wait for a second
  digitalWrite(LED_BUILTIN, LOW);    // turn the LED off by making the voltage LOW
  delay(1000);                       // wait for a second
}

------------------------------------------------------------------------------------------------------------------------

2. Study of NodeMCU interfacing with Ultrasonic Distance Sensor.

Code:

#define PINTRIG 23
#define PINECHO 22
void setup()
{
  pinMode(PINTRIG, OUTPUT);
  pinMode(PINECHO, INPUT);
  Serial.begin(9600);
}

void loop()
{
  digitalWrite(PINTRIG, LOW);
  delayMicroseconds(5); // Wait for 5 microsecond(s)
  digitalWrite(PINTRIG, HIGH);
  delayMicroseconds(10); // Wait for 5 microsecond(s)
  digitalWrite(PINTRIG,LOW);
  
  long duration = pulseIn(PINECHO,HIGH);
  float cm_dist = (duration / 2.0) * (349.50*100/1000000);
  float in_dist = (cm_dist * .393701);
  
  Serial.write(" Raw Value: ");
  Serial.print(duration);
  Serial.print(",");
  Serial.write(" Cms: ");
  Serial.print(cm_dist);
  Serial.print(",");
  Serial.write("Inches: ");
  Serial.println(in_dist);
  delay(1000);
}

------------------------------------------------------------------------------------------------------------------------

3. Study of NodeMCU interfacing with DHT11 Temperature Sensor.

Code:

#include <DHT.h>
#define DHT_SENSOR_PIN  23 // ESP32 pin GIOP21 connected to DHT11 sensor
#define DHT_SENSOR_TYPE DHT11

DHT dht_sensor(DHT_SENSOR_PIN, DHT_SENSOR_TYPE);

void setup() {
  Serial.begin(9600);
  dht_sensor.begin(); // initialize the DHT sensor
}

void loop() {
  // read humidity
  float humi  = dht_sensor.readHumidity();
  // read temperature in Celsius
  float tempC = dht_sensor.readTemperature();
  // read temperature in Fahrenheit
  float tempF = dht_sensor.readTemperature(true);

  // check whether the reading is successful or not
  if ( isnan(tempC) || isnan(tempF) || isnan(humi)) {
    Serial.println("Failed to read from DHT sensor!");
  } else {
    Serial.print("Humidity: ");
    Serial.print(humi);
    Serial.print("%");

    Serial.print("  |  ");

    Serial.print("Temperature: ");
    Serial.print(tempC);
    Serial.print("°C  ~  ");
    Serial.print(tempF);
    Serial.println("°F");
  }

  // wait a 2 seconds between readings
  delay(2000);
}

------------------------------------------------------------------------------------------------------------------------

4. Study of NodeMCU - Bluetooth Interfacing.

Code:

#include "BluetoothSerial.h"

#if !defined(CONFIG_BT_ENABLED) || !defined(CONFIG_BLUEDROID_ENABLED)
#error Bluetooth is not enabled! Please run `make menuconfig` to and enable it
#endif

BluetoothSerial SerialBT;

void setup() {
  Serial.begin(115200);
  SerialBT.begin("Unknown Anonymous TryHard"); //Bluetooth device name
  Serial.println("The device started, now you can pair it with bluetooth!");
}

void loop() {
  if (Serial.available()) {
    SerialBT.write(Serial.read());
  }
  if (SerialBT.available()) {
    Serial.write(SerialBT.read());
  }
  delay(20);
}

------------------------------------------------------------------------------------------------------------------------

5. Study of NodeMCU - Wifi Interfacing with Thingspeak & DHT11.

Code:

#include <WiFi.h>
#include "ThingSpeak.h"

const char* ssid = "<YOUR_SSID_NAME>";   // your network SSID (name) 
const char* password = "<YOUR_SSID_PASSWORD>";   // your network password

WiFiClient  client;

unsigned long myChannelNumber = <YOUR_CHANNEL_NUMBER>;
const char * myWriteAPIKey = "<YOUR_WRITE_API_KEY>";

// Timer variables
unsigned long lastTime = 0;
unsigned long timerDelay = 30000;

// Variable to hold temperature readings
float temperatureC;
//uncomment if you want to get temperature in Fahrenheit
//float temperatureF;

// Create a sensor object
 //BME280 connect to ESP32 I2C (GPIO 21 = SDA, GPIO 22 = SCL)



void setup() {
  Serial.begin(115200);  //Initialize serial
  
  WiFi.mode(WIFI_STA);   
  
  ThingSpeak.begin(client);  // Initialize ThingSpeak
}

void loop() {
  if ((millis() - lastTime) > timerDelay) {
    
    // Connect or reconnect to WiFi
    if(WiFi.status() != WL_CONNECTED){
      Serial.print("Attempting to connect");
      while(WiFi.status() != WL_CONNECTED){
        WiFi.begin(ssid, password); 
        delay(5000);     
      } 
      Serial.println("\nConnected.");
    }

    // Get a new temperature reading
    temperatureC = rand();
    Serial.print("Temperature (ºC): ");
    Serial.println(temperatureC);
    
    //uncomment if you want to get temperature in Fahrenheit
    /*temperatureF = 1.8 * bme.readTemperature() + 32;
    Serial.print("Temperature (ºC): ");
    Serial.println(temperatureF);*/
    
    
    // Write to ThingSpeak. There are up to 8 fields in a channel, allowing you to store up to 8 different
    // pieces of information in a channel.  Here, we write to field 1.
    int x = ThingSpeak.writeField(myChannelNumber, 1, temperatureC, myWriteAPIKey);
    //uncomment if you want to get temperature in Fahrenheit
    //int x = ThingSpeak.writeField(myChannelNumber, 1, temperatureF, myWriteAPIKey);

    if(x == 200){
      Serial.println("Channel update successful.");
    }
    else{
      Serial.println("Problem updating channel. HTTP error code " + String(x));
    }
    lastTime = millis();
  }
}

------------------------------------------------------------------------------------------------------------------------

6. Study of NodeMCU interfacing with MQ2 Gas Sensor.

Code:

int Gas_analog = 32;    // used for ESP32
int Gas_digital = 23;   // used for ESP32

void setup() {
  Serial.begin(115200);  
  pinMode(LED_BUILTIN,OUTPUT);   
  pinMode(Gas_digital, INPUT);
}

void loop() {
  int gassensorAnalog = analogRead(Gas_analog);
  int gassensorDigital = digitalRead(Gas_digital);

  Serial.print("Gas Sensor: ");
  Serial.print(gassensorAnalog);
  Serial.print("\t");
  Serial.print("Gas Class: ");
  Serial.print(gassensorDigital);
  Serial.print("\t");
  
  if (gassensorAnalog > 1000) {
    Serial.println("Gas\n");
    digitalWrite(LED_BUILTIN,HIGH);
    Serial.print("\t");
    digitalWrite(LED_BUILTIN,LOW);
  }
  else {
    Serial.println("No Gas\n");
    digitalWrite(LED_BUILTIN,LOW);
  }
  delay(1000);
}

------------------------------------------------------------------------------------------------------------------------

7. In-Class Real-Life Project: Design a Smoke & Fire Detection Module capable of the following features (category wise).

Code:

#include "DHT.h"
#define DHT11PIN 22
DHT dht(DHT11PIN, DHT11);

int Gas_analog = 32;    // used for ESP32
int Gas_digital = 23;   // used for ESP32

void setup() {
  Serial.begin(115200);
  dht.begin();      
  pinMode(Gas_digital, INPUT);
}

void loop() {
  int gassensorAnalog = analogRead(Gas_analog);
  int gassensorDigital = digitalRead(Gas_digital);
  float temp = dht.readTemperature();

  if (gassensorAnalog > 1200 && temp > 20) {
   Serial.println("CATEGORY 1 SMOKE AND FIRE DETECTED!!");
  }
 else {
   
   if (gassensorAnalog > 1200) {
     Serial.println("CATEGORY 3 SMOKE ONLY DETECTED!!");
    }
   else {
     Serial.println("NO SMOKE ");
    }
    if (temp > 20) {
     Serial.println("CATEGORY 2 SMOKELESS FIRE DETECTED!!!");
    }
   else {
     Serial.println("NO FIRE");
    }
 }
 delay(3000);
}

------------------------------------------------------------------------------------------------------------------------

8.  In-Class Real-Life Project (CONTINUED): Design a Smoke & Fire Detection Module capable of the following features (with ThingSpeak) [random function].

Code:

#include <WiFi.h>
#include "ThingSpeak.h"

const char* ssid = "YOUR_SSID_NETWORK_NAME";   // your network SSID (name) 
const char* password = "YOUR_SSID_PASSWORD";   // your network password
WiFiClient  client;
unsigned long myChannelNumber = <YOUR CHANNEL NUMBER>;
const char * myWriteAPIKey = "<YOUR_API_KEY>";
unsigned long lastTime = 0;
unsigned long timerDelay = 10000;

void setup() {
  Serial.begin(115200);     
  WiFi.mode(WIFI_STA);   
  ThingSpeak.begin(client);
}

void loop() {

   if ((millis() - lastTime) > timerDelay) {

    // Connect or reconnect to WiFi
    if(WiFi.status() != WL_CONNECTED){
      Serial.print("Attempting to connect");
      while(WiFi.status() != WL_CONNECTED){
        WiFi.begin(ssid, password); 
        delay(5000);     
      } 
      Serial.println("\nConnected.");
    }

    int gassensorAnalog =random(200,3000);
    int gassensorDigital = random(200,3000);
  
    Serial.print("Gas Sensor: ");
    Serial.print(gassensorAnalog);
    float t = random(10,50);
    if (isnan(t)) {
      Serial.println(F("Failed to read from DHT sensor!"));
      return;
    }
    Serial.print(F("%  Temperature: "));
    Serial.print(t);
    
    int category =0;
    if(t>30 && gassensorAnalog <= 1000) {
      Serial.println("SMOKELESS FIRE DETECTED"); 
      category =3;
    }
    if(t<=30 && gassensorAnalog > 1000) {
      Serial.println("SMOKE ONLY DETECTED");
      category =2;
    }
    if(t>30 && gassensorAnalog > 1000) {
      Serial.println("SMOKE AND FIRE DETECTED");
      category =1;
    }
    if(t<=30 && gassensorAnalog <= 1000) {
      Serial.println("SMOKE AND FIRE NOT DETECTED");
      category =0;
    }

    ThingSpeak.setField(1, gassensorAnalog);
    ThingSpeak.setField(2, t);
    ThingSpeak.setField(3, category);
    
    int x = ThingSpeak.writeFields(myChannelNumber, myWriteAPIKey);
    if(x == 200){
      Serial.println("Channel update successful.");
    }
    else{
      Serial.println("Problem updating channel. HTTP error code " + String(x));
    
     }
    lastTime = millis();
  }
}